#!/usr/bin/env python3
"""
🎯 TARGETED PENETRATION TESTING
============================
Runs a full penetration test against a specified target using all framework capabilities.
This performs actual penetration testing operations including vulnerability exploitation.
"""

import logging
import time
import json
import os
import argparse
from datetime import datetime

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

def setup_argument_parser():
    """Set up command line argument parser"""
    parser = argparse.ArgumentParser(description='Run targeted penetration testing operation')
    parser.add_argument('--target', required=True, help='Target IP address or hostname')
    parser.add_argument('--network', default='192.168.1.0/24', help='Network CIDR for scanning')
    parser.add_argument('--intensity', type=int, default=8, choices=range(1,11),
                        help='Intensity level (1-10)')
    parser.add_argument('--stealth', action='store_true', help='Use stealth mode')
    return parser

def run_targeted_pentest(target, network, intensity=8, stealth_mode=False):
    """Run a full penetration test against the specified target"""
    
    logger.info(f"🎯 Starting targeted penetration test against {target}")
    logger.info(f"Network scope: {network}")
    logger.info(f"Intensity level: {intensity}/10")
    logger.info(f"Stealth mode: {'Enabled' if stealth_mode else 'Disabled'}")
    
    # Import all required modules
    from main import UnifiedCybersecurityFramework
    from ai_modules.reconnet_v4 import ReconNetV4, ExploitGPT
    from zero_day_arsenal.zero_day_arsenal import ZeroDayArsenal
    
    # Initialize the framework
    framework = UnifiedCybersecurityFramework()
    
    # Initialize specific modules
    recon = ReconNetV4()
    exploit_gen = ExploitGPT()
    arsenal = ZeroDayArsenal()
    
    # PHASE 1: Initial Reconnaissance
    logger.info("PHASE 1: Performing initial reconnaissance...")
    recon_results = recon.run_reconnaissance(
        [network],
        scan_intensity=intensity,
        stealth_mode=stealth_mode,
        service_detection=True,
        os_fingerprinting=True,
        vulnerability_scanning=True
    )
    
    logger.info(f"Initial reconnaissance complete. Found {len(recon_results['systems'])} systems.")
    
    # Find our specific target in the results
    target_system = None
    for system in recon_results['systems']:
        if system['ip'] == target:
            target_system = system
            break
    
    if not target_system:
        logger.warning(f"Target {target} was not found in reconnaissance results.")
        logger.info("Performing direct scan of the target...")
        target_system = recon.scan_target(target, intensity=intensity, stealth_mode=stealth_mode)
    
    # Print target information
    print("\n" + "="*70)
    print(f"🎯 TARGET INFORMATION: {target}")
    print("="*70)
    print(f"OS: {target_system['os_fingerprint']} ({target_system['os_confidence']*100:.1f}% confidence)")
    print(f"Open ports: {', '.join(str(p) for p in target_system['open_ports'][:15])}")
    print(f"Services:")
    for service in target_system['services'][:10]:
        print(f"  - {service}")
    
    # PHASE 2: Vulnerability Assessment
    logger.info("PHASE 2: Performing detailed vulnerability assessment...")
    
    # Filter vulnerabilities specific to our target
    target_vulns = [v for v in recon_results['vulnerabilities'] if v['affected_system'] == target]
    
    # If no vulnerabilities found, perform deeper scan
    if not target_vulns:
        logger.info("No vulnerabilities found in initial scan. Performing deeper vulnerability assessment...")
        target_vulns = recon.deep_vulnerability_scan(target, intensity=intensity)
    
    print("\n" + "="*70)
    print(f"🔍 VULNERABILITY ASSESSMENT: {len(target_vulns)} vulnerabilities found")
    print("="*70)
    
    # Sort vulnerabilities by CVSS score
    sorted_vulns = sorted(target_vulns, key=lambda x: x['cvss'], reverse=True)
    
    for i, vuln in enumerate(sorted_vulns[:10]):  # Show top 10 vulnerabilities
        print(f"{i+1}. {vuln['name']} (CVSS: {vuln['cvss']})")
        print(f"   ID: {vuln['id']}")
        print(f"   Description: {vuln['description'][:100]}..." if len(vuln['description']) > 100 
              else f"   Description: {vuln['description']}")
        print(f"   Affected service: {vuln.get('affected_service', 'Unknown')}")
        print()
    
    # PHASE 3: Exploit Development
    logger.info("PHASE 3: Analyzing exploitability and developing attack vectors...")
    
    exploitable_vulns = []
    for vuln in sorted_vulns:
        if vuln['cvss'] >= 7.0:  # Focus on high-severity vulnerabilities
            try:
                # Generate exploit for the vulnerability
                exploit = exploit_gen.generate_exploit(vuln)
                
                if exploit['reliability'] >= 0.7:  # Only include reasonably reliable exploits
                    exploitable_vulns.append({
                        'vulnerability': vuln,
                        'exploit': exploit
                    })
                    logger.info(f"Generated exploit for {vuln['name']} with {exploit['reliability']*100:.1f}% reliability")
            except Exception as e:
                logger.error(f"Failed to generate exploit for {vuln['name']}: {str(e)}")
    
    print("\n" + "="*70)
    print(f"💥 EXPLOIT DEVELOPMENT: {len(exploitable_vulns)} viable attack vectors")
    print("="*70)
    
    for i, item in enumerate(exploitable_vulns[:5]):  # Show top 5 exploitable vulnerabilities
        vuln = item['vulnerability']
        exploit = item['exploit']
        
        print(f"{i+1}. {vuln['name']}")
        print(f"   Exploit ID: {exploit['exploit_id']}")
        print(f"   Reliability: {exploit['reliability']*100:.1f}%")
        print(f"   Evasion score: {exploit['evasion_score']*100:.1f}%")
        print(f"   Type: {exploit['type']}")
        print()
    
    # PHASE 4: Advanced Capabilities
    # Check for zero-day potential
    logger.info("PHASE 4: Analyzing for zero-day vulnerability potential...")
    
    # Check if target has potential for zero-day discovery
    zeroday_results = arsenal.analyze_zeroday_potential(target_system)
    
    if zeroday_results['zeroday_potential'] > 0.6:  # High potential for zero-day
        print("\n" + "="*70)
        print("🔬 ZERO-DAY POTENTIAL ANALYSIS")
        print("="*70)
        print(f"Zero-day potential: {zeroday_results['zeroday_potential']*100:.1f}%")
        print(f"Target technology stack vulnerabilities:")
        
        for tech, risk in zeroday_results['technology_risks'].items():
            print(f"  - {tech}: {risk*100:.1f}% risk factor")
        
        if 'potential_targets' in zeroday_results:
            print("\nPotential zero-day targets:")
            for t in zeroday_results['potential_targets'][:5]:
                print(f"  - {t['component']} ({t['reason']})")
    
    # PHASE 5: Reporting
    logger.info("PHASE 5: Generating comprehensive pentest report...")
    
    # Create report structure
    report = {
        "pentest_id": f"PT-{int(time.time())}",
        "target": target,
        "network_scope": network,
        "timestamp": datetime.now().isoformat(),
        "target_info": target_system,
        "vulnerabilities": sorted_vulns,
        "exploitable_vulnerabilities": [
            {
                "vulnerability": item['vulnerability'],
                "exploit": {k: v for k, v in item['exploit'].items() if k != 'payload'}  # Exclude actual payload
            }
            for item in exploitable_vulns
        ],
        "risk_assessment": {
            "overall_risk": calculate_risk(sorted_vulns),
            "critical_findings": len([v for v in sorted_vulns if v['cvss'] >= 9.0]),
            "high_findings": len([v for v in sorted_vulns if 7.0 <= v['cvss'] < 9.0]),
            "medium_findings": len([v for v in sorted_vulns if 4.0 <= v['cvss'] < 7.0]),
            "low_findings": len([v for v in sorted_vulns if v['cvss'] < 4.0]),
        },
        "remediation_priorities": generate_remediation_priorities(sorted_vulns)
    }
    
    # Save report to file
    report_file = f"pentest_report_{report['pentest_id']}.json"
    with open(report_file, 'w') as f:
        json.dump(report, f, indent=2)
    
    # Print summary
    print("\n" + "="*70)
    print("📊 PENETRATION TEST SUMMARY")
    print("="*70)
    print(f"Target: {target}")
    print(f"Total vulnerabilities discovered: {len(sorted_vulns)}")
    print(f"Exploitable vulnerabilities: {len(exploitable_vulns)}")
    print(f"Overall risk assessment: {report['risk_assessment']['overall_risk']}")
    print(f"\nVulnerability breakdown:")
    print(f"  Critical: {report['risk_assessment']['critical_findings']}")
    print(f"  High: {report['risk_assessment']['high_findings']}")
    print(f"  Medium: {report['risk_assessment']['medium_findings']}")
    print(f"  Low: {report['risk_assessment']['low_findings']}")
    
    print(f"\nDetailed penetration test report saved to: {report_file}")
    
    logger.info(f"Penetration test completed. Report generated: {report_file}")
    
    return {
        "pentest_id": report['pentest_id'],
        "report_file": report_file,
        "vulnerabilities": len(sorted_vulns),
        "exploitable": len(exploitable_vulns),
        "risk_level": report['risk_assessment']['overall_risk']
    }

def calculate_risk(vulnerabilities):
    """Calculate overall risk level based on vulnerabilities"""
    if not vulnerabilities:
        return "Low"
    
    # Calculate weighted score
    critical = len([v for v in vulnerabilities if v['cvss'] >= 9.0])
    high = len([v for v in vulnerabilities if 7.0 <= v['cvss'] < 9.0])
    medium = len([v for v in vulnerabilities if 4.0 <= v['cvss'] < 7.0])
    
    score = (critical * 10 + high * 5 + medium * 2) / len(vulnerabilities)
    
    # Determine risk level
    if score >= 8:
        return "Critical"
    elif score >= 5:
        return "High"
    elif score >= 2:
        return "Medium"
    else:
        return "Low"

def generate_remediation_priorities(vulnerabilities):
    """Generate prioritized remediation recommendations"""
    if not vulnerabilities:
        return []
    
    # Group vulnerabilities by type/category
    categories = {}
    for vuln in vulnerabilities:
        category = vuln.get('category', 'General')
        if category not in categories:
            categories[category] = []
        categories[category].append(vuln)
    
    # Generate recommendations
    recommendations = []
    for category, vulns in categories.items():
        # Sort by severity
        sorted_vulns = sorted(vulns, key=lambda x: x['cvss'], reverse=True)
        
        # Take top vulnerability as representative
        top_vuln = sorted_vulns[0]
        
        recommendations.append({
            "category": category,
            "priority": len(sorted_vulns),
            "severity": "Critical" if top_vuln['cvss'] >= 9.0 else 
                        "High" if top_vuln['cvss'] >= 7.0 else 
                        "Medium" if top_vuln['cvss'] >= 4.0 else "Low",
            "vulnerabilities": len(sorted_vulns),
            "representative_issue": top_vuln['name'],
            "remediation": top_vuln.get('remediation', "Apply vendor patches and follow secure configuration guidelines"),
            "affected_systems": len(set(v.get('affected_system') for v in sorted_vulns if 'affected_system' in v))
        })
    
    # Sort by priority
    return sorted(recommendations, key=lambda x: x['priority'], reverse=True)

if __name__ == "__main__":
    parser = setup_argument_parser()
    args = parser.parse_args()
    
    try:
        result = run_targeted_pentest(
            args.target,
            args.network,
            args.intensity,
            args.stealth
        )
        print(f"\n✅ Penetration test completed: {result['pentest_id']}")
        print(f"Risk level: {result['risk_level']}")
        print(f"Full report available at: {result['report_file']}")
    except Exception as e:
        logger.error(f"Error during penetration test: {str(e)}")
        raise